#' Prepare DAM Activity Data for HMM Analysis
#'
#' @description
#' Processes Drosophila Activity Monitor (DAM) data by loading raw monitor files,
#' linking them with metadata, calculating derived features (day, phase, normalized
#' activity), and filtering by date range. The output is a \code{behavr} table
#' ready for Hidden Markov Model analysis.
#'
#' This is typically the first step in the FlyDreamR workflow, converting raw
#' DAM files into a standardized format suitable for \code{\link{HMMbehavr}}.
#'
#' @param metafile_path Character string. Full path to the metadata CSV file
#'   generated by \code{\link{convMasterToMeta}}. This file must contain columns:
#'   \code{file}, \code{start_datetime}, \code{stop_datetime}, \code{region_id},
#'   \code{genotype}, and \code{replicate}.
#' @param result_dir Character string. Directory path containing the raw DAM
#'   monitor files referenced in the metadata. Defaults to current working
#'   directory (\code{getwd()}).
#' @param ldcyc Numeric. Duration of the light phase in hours within a 24-hour
#'   cycle. For example, use 12 for LD 12:12, or 16 for LD 16:8. Default: 12.
#'   Used to assign time points to "Light" or "Dark" phases.
#' @param day_range Numeric vector of length 2. Specifies \code{c(start_day, end_day)}
#'   to retain for analysis (inclusive). Days are numbered starting from 1.
#'   \itemize{
#'     \item Use \code{c(1, 3)} to keep days 1, 2, and 3
#'     \item Use \code{c(2, 2)} to keep only day 2
#'     \item Use \code{c(1, 5)} to keep days 1 through 5
#'   }
#'   Default: \code{c(1, 2)} (first two days).
#' @param sd_day Numeric or NULL. Day number on which sleep deprivation occurred.
#'   If NULL (default), no special handling for sleep deprivation is applied.
#'   Example: \code{sd_day = 3} indicates sleep deprivation on day 3.
#' @param sd_duration Numeric or NULL. Duration of sleep deprivation in hours.
#'   Only used if \code{sd_day} is specified. Default: NULL.
#'   Example: \code{sd_duration = 12} for 12 hours of sleep deprivation.
#' @param sd_start_hour Numeric. Hour within the day when sleep deprivation starts
#'   (0-24, where 0 is the start of the day/ZT0). Default: 0.
#'   Example: \code{sd_start_hour = 12} means SD starts 12 hours into the day.
#' @param ... Additional arguments passed to \code{\link{sleepDAMAnnotation}}.
#'   Most commonly used:
#'   \describe{
#'     \item{\code{min_time_immobile}}{A vector of length 2 specifying the
#'       minimum and maximum duration (in seconds) for an immobility bout to be
#'       considered sleep. Default: \code{c(behavr::mins(5), behavr::mins(1440))}.
#'       For example, use \code{c(behavr::mins(10), behavr::mins(1440))} to
#'       require 10 minutes of immobility.}
#'   }
#'
#' @return A \code{behavr} table (class \code{behavr} and \code{data.table})
#'   containing processed activity data with both original metadata columns and
#'   newly calculated columns:
#'
#'   **Metadata columns** (from input):
#'   \itemize{
#'     \item \code{id}: Unique identifier for each individual
#'     \item \code{genotype}: Genotype/line identifier
#'     \item \code{replicate}: Replicate identifier
#'   }
#'
#'   **Activity columns** (from DAM files):
#'   \itemize{
#'     \item \code{t}: Time in seconds from experiment start
#'     \item \code{activity}: Raw activity count (beam crossings)
#'     \item \code{asleep}: Logical, sleep state annotation
#'   }
#'
#'   **Calculated columns** (added by this function):
#'   \itemize{
#'     \item \code{moving}: Logical, \code{TRUE} if activity > 0
#'     \item \code{day}: Integer day number (1, 2, 3, ...)
#'     \item \code{phase}: Factor with levels "Light" and "Dark"
#'     \item \code{normact}: Normalized activity as percentage of daily total (0-100)
#'     \item \code{sd_period}: Logical, \code{TRUE} during sleep deprivation period (if applicable)
#'   }
#'
#' @details
#' ## Activity Normalization
#' \code{normact} represents activity as a percentage of total daily activity:
#' \code{normact = (activity / sum(daily_activity)) * 100}
#'
#' This normalization accounts for individual differences in baseline activity
#' levels and is used by the HMM fitting process.
#'
#' **With Sleep Deprivation**: Each period (SD and non-SD) is normalized proportionally
#' based on its duration. For example, with a 12-hour SD period:
#' \itemize{
#'   \item SD period: normalized to sum to 50\% (12/24 * 100)
#'   \item Non-SD period: normalized to sum to 50\% (12/24 * 100)
#'   \item Total daily normact: 100\%
#' }
#' This maintains the 100\% total per day while preserving separate normalization
#' structure for SD vs non-SD periods.
#'
#' ## Sleep Deprivation Handling
#' When \code{sd_day}, \code{sd_duration}, and \code{sd_start_hour} are specified:
#' \itemize{
#'   \item The sleep deprivation period is normalized separately (as percentage of
#'     activity during that period only)
#'   \item The remaining hours of the SD day are normalized separately (as percentage
#'     of activity during the non-SD period of that day)
#'   \item All other days are normalized normally
#'   \item A new column \code{sd_period} indicates which timepoints fall within the
#'     sleep deprivation period
#'   \item If the SD period extends beyond 24 hours (e.g., starts at hour 18 for 12 hours),
#'     it will span into the next day, and both days will be handled with separate
#'     normalization for SD and non-SD periods
#' }
#'
#' ## Error Handling
#' The function will stop with an error if:
#' \itemize{
#'   \item Metadata file doesn't exist or can't be read
#'   \item DAM files referenced in metadata are missing
#'   \item No data remains after day filtering
#'   \item Required columns are missing from loaded data
#' }
#'
#' @examples
#' \dontrun{
#' # Basic usage with default parameters
#' processed_data <- HMMDataPrepSD(
#'   metafile_path = "metadata/Metadata_Monitor1.csv"
#' )
#'
#' # With sleep deprivation on day 3 for 12 hours starting at hour 12
#' processed_data <- HMMDataPrepSD(
#'   metafile_path = "metadata/experiment1_metadata.csv",
#'   result_dir = "raw_dam_files/",
#'   day_range = c(1, 5),
#'   sd_day = 3,
#'   sd_duration = 12,
#'   sd_start_hour = 12
#' )
#'
#' # Check sleep deprivation period
#' table(processed_data$sd_period, processed_data$day)
#' }
#'
#' @seealso
#' \code{\link{convMasterToMeta}} for generating metadata files
#' \code{\link{HMMbehavr}} for running HMM analysis on prepared data
#' \code{\link{sleepDAMAnnotation}} for sleep annotation details
#' \code{\link[damr]{load_dam}} for DAM file loading
#'
#' @export
#' @import data.table
#' @importFrom damr link_dam_metadata load_dam
#' @importFrom behavr xmv days hours setbehavr is.behavr
#' @importFrom cli cli_alert_success cli_alert_info cli_alert_warning cli_alert_danger col_yellow col_cyan col_green col_red
#' @importFrom stats quantile na.omit
#' @importFrom utils packageVersion
HMMDataPrepSD <- function(metafile_path,
                          result_dir = getwd(),
                          ldcyc = 12,
                          day_range = c(1, 2),
                          sd_day = NULL,
                          sd_duration = NULL,
                          sd_start_hour = 0,
                          ...) {
  # --- 1. Input Validation and Setup ---
  # Check required packages silently, stop if missing
  pkgs <- c("data.table", "damr", "behavr", "cli")
  missing_pkgs <- pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
  if (length(missing_pkgs) > 0) {
    stop("Required packages are not installed: ", paste(missing_pkgs, collapse = ", "))
  }

  # Validate inputs
  if (!is.character(metafile_path) || length(metafile_path) != 1 || !file.exists(metafile_path)) {
    stop("`metafile_path` must be a valid path to an existing file.")
  }
  if (!is.character(result_dir) || length(result_dir) != 1) {
    stop("`result_dir` must be a single character string path.")
  }
  # Check if directory exists, warn if not (damr might handle some cases)
  if (!dir.exists(result_dir)) {
    cli::cli_alert_warning("Specified `result_dir` does not exist: {.path {result_dir}}", wrap = TRUE)
  }
  if (!is.numeric(ldcyc) || length(ldcyc) != 1 || !is.finite(ldcyc) || ldcyc <= 0 || ldcyc >= 24) {
    cli::cli_alert_warning("`ldcyc` should be a single positive number < 24. Resetting to default: 12")
    ldcyc <- 12
  }
  if (!is.numeric(day_range) || length(day_range) != 2 || any(!is.finite(day_range)) || day_range[1] < 1 || day_range[2] < day_range[1]) {
    stop("`day_range` must be a numeric vector of length 2 (start_day, end_day), with start_day >= 1 and end_day >= start_day.")
  }
  day_range <- floor(day_range) # Ensure integer days

  # Validate sleep deprivation parameters
  sd_enabled <- FALSE
  if (!is.null(sd_day) || !is.null(sd_duration)) {
    if (is.null(sd_day) || is.null(sd_duration)) {
      stop("Both `sd_day` and `sd_duration` must be specified together, or both NULL.")
    }
    if (!is.numeric(sd_day) || length(sd_day) != 1 || !is.finite(sd_day) || sd_day < 1) {
      stop("`sd_day` must be a single positive number >= 1.")
    }
    if (!is.numeric(sd_duration) || length(sd_duration) != 1 || !is.finite(sd_duration) || sd_duration <= 0 || sd_duration > 24) {
      stop("`sd_duration` must be a single positive number > 0 and <= 24.")
    }
    if (!is.numeric(sd_start_hour) || length(sd_start_hour) != 1 || !is.finite(sd_start_hour) || sd_start_hour < 0 || sd_start_hour >= 24) {
      stop("`sd_start_hour` must be a single number >= 0 and < 24.")
    }
    if (sd_start_hour + sd_duration > 24) {
      cli::cli_alert_warning("SD period extends beyond 24 hours (start: {sd_start_hour}h, duration: {sd_duration}h). SD will span into the next day.")
    }
    sd_day <- floor(sd_day)
    sd_enabled <- TRUE
    cli::cli_alert_info("Sleep deprivation enabled: Day {sd_day}, from hour {sd_start_hour} for {sd_duration}h")
  }

  cli::cli_alert_info("Starting data preparation...")
  cli::cli_alert_info("Using parameters: light_duration={ldcyc}h, day_range=[{day_range[1]}, {day_range[2]}]")

  # --- 2. Load Metadata ---
  metadata <- tryCatch(
    {
      data.table::fread(paste0(metafile_path), na.strings = c("NA", ""))
    },
    error = function(e) {
      stop("Failed to read metadata file: ", metafile_path, "\nError details: ", e$message)
    }
  )
  cli::cli_alert_success("Metadata file read successfully: {.path {metafile_path}}")

  # --- 3. Handle Missing Data in Metadata---
  initial_rows <- nrow(metadata)
  metadata <- stats::na.omit(metadata)
  final_rows <- nrow(metadata)
  if (final_rows < initial_rows) {
    cli::cli_alert_warning("{initial_rows - final_rows} rows removed from metadata due to NA values.")
  }
  if (final_rows == 0) {
    stop("No valid metadata rows remaining after removing NAs. Cannot proceed.")
  }

  # --- 4. Link Metadata to DAM Files ---
  metadata_proc <- tryCatch(
    {
      damr::link_dam_metadata(metadata, result_dir = result_dir)
    },
    error = function(e) {
      stop("Failed during `damr::link_dam_metadata`. Check metadata content (esp. file references) and `result_dir` path.\nError details: ", e$message)
    }
  )
  cli::cli_alert_success(cli::style_bold(cli::col_yellow("Metadata linked to DAM files.")))

  # --- 5. Load DAM Activity Data ---
  dt <- tryCatch(
    {
      damr::load_dam(metadata_proc, FUN = FlyDreamR:::sleepDAMAnnotation, ...)
    },
    error = function(e) {
      stop("Failed during `damr::load_dam`. Check DAM file paths in metadata and file integrity.\nError details: ", e$message)
    }
  )
  cli::cli_alert_success(cli::style_bold(cli::col_cyan("DAM activity data loaded ({nrow(dt)} rows).")))

  # --- 6. Basic Feature: Moving Status ---
  dt[, moving := activity > 0]
  dt[, genotype := behavr::xmv(genotype)]
  dt[, replicate := behavr::xmv(replicate)]

  # --- 7. Calculate Day ---
  if (!"t" %in% names(dt)) {
    stop("Required column 't' (time in seconds) not found after loading data. Check `damr::load_dam` behavior.")
  }
  dt[, day := floor(t / behavr::days(1)) + 1]

  # --- 8. Calculate Phase ---
  dt[, phase := ifelse(t %% behavr::hours(24) >= behavr::hours(ldcyc), "Dark", "Light")]
  dt[, phase := factor(phase, levels = c("Light", "Dark"))]

  # --- 9. Filter by Day Range ---
  initial_rows_filter <- nrow(dt)
  dt <- dt[data.table::between(day, day_range[1], day_range[2], incbounds = TRUE)]
  final_rows_filter <- nrow(dt)
  cli::cli_alert_info("Filtered data by day range [{day_range[1]}, {day_range[2]}]. Kept {final_rows_filter} of {initial_rows_filter} rows.")

  if (final_rows_filter == 0) {
    cli::cli_alert_danger(cli::style_bold(cli::col_red(
      "CRITICAL: No data remains after filtering for day range [{day_range[1]}, {day_range[2]}]. Check input data coverage and `day_range` parameter."
    )))
    stop("No data remains after day filtering.")
  }

  # --- 10. Mark Sleep Deprivation Period ---
  if (sd_enabled) {
    # Calculate time within day (seconds from start of that day)
    dt[, time_in_day := t %% behavr::days(1)]

    # Mark SD period: during sd_day (and potentially next day if it spans over)
    sd_start_time <- behavr::hours(sd_start_hour)
    sd_end_time <- behavr::hours(sd_start_hour + sd_duration)

    # Handle cases where SD period spans into next day
    if (sd_end_time > behavr::days(1)) {
      # SD spans two days
      dt[, sd_period := (
        (day == sd_day & time_in_day >= sd_start_time) |
          (day == (sd_day + 1) & time_in_day < (sd_end_time - behavr::days(1)))
      )]
    } else {
      # SD is within a single day
      dt[, sd_period := (day == sd_day) & (time_in_day >= sd_start_time) & (time_in_day < sd_end_time)]
    }

    cli::cli_alert_info("Marked sleep deprivation period: {sum(dt$sd_period)} timepoints")
  } else {
    dt[, sd_period := FALSE]
  }

  # --- 11. Normalize Activity with SD Handling ---
  if (sd_enabled) {
    # Determine which days are affected by SD
    sd_end_time_total <- behavr::hours(sd_start_hour + sd_duration)
    sd_spans_days <- sd_end_time_total > behavr::days(1)
    affected_days <- if (sd_spans_days) c(sd_day, sd_day + 1) else sd_day

    # Calculate the proportion of each day occupied by SD period
    # For each affected day, determine how many hours of SD fall on that day
    sd_proportions <- list()
    if (sd_spans_days) {
      # SD period spans two days
      # First day: from sd_start_hour to end of day (24h)
      hours_day1_sd <- 24 - sd_start_hour
      hours_day1_nonsd <- sd_start_hour
      sd_proportions[[as.character(sd_day)]] <- list(
        sd_prop = hours_day1_sd / 24,
        nonsd_prop = hours_day1_nonsd / 24
      )

      # Second day: from start of day to end of SD
      hours_day2_sd <- (sd_start_hour + sd_duration) - 24
      hours_day2_nonsd <- 24 - hours_day2_sd
      sd_proportions[[as.character(sd_day + 1)]] <- list(
        sd_prop = hours_day2_sd / 24,
        nonsd_prop = hours_day2_nonsd / 24
      )
    } else {
      # SD period within single day
      sd_proportions[[as.character(sd_day)]] <- list(
        sd_prop = sd_duration / 24,
        nonsd_prop = (24 - sd_duration) / 24
      )
    }

    dt[, normact := {
      if (day[1] %in% affected_days) {
        # This day is affected by sleep deprivation
        result <- numeric(length(activity))

        # Get proportions for this specific day
        day_props <- sd_proportions[[as.character(day[1])]]
        target_sd_pct <- day_props$sd_prop * 100
        target_nonsd_pct <- day_props$nonsd_prop * 100

        # Normalize SD period: each activity as % of SD total, then scale to target %
        sd_idx <- sd_period
        if (sum(sd_idx) > 0) {
          sd_total <- sum(activity[sd_idx], na.rm = TRUE)
          if (sd_total > 0) {
            # Normalize within SD period, then scale to contribute target_sd_pct to the day
            result[sd_idx] <- (activity[sd_idx] / sd_total) * target_sd_pct
          } else {
            result[sd_idx] <- 0
          }
        }

        # Normalize non-SD period: each activity as % of non-SD total, then scale to target %
        non_sd_idx <- !sd_period
        if (sum(non_sd_idx) > 0) {
          non_sd_total <- sum(activity[non_sd_idx], na.rm = TRUE)
          if (non_sd_total > 0) {
            # Normalize within non-SD period, then scale to contribute target_nonsd_pct to the day
            result[non_sd_idx] <- (activity[non_sd_idx] / non_sd_total) * target_nonsd_pct
          } else {
            result[non_sd_idx] <- 0
          }
        }

        result
      } else {
        # Normal day: normalize across entire day
        daily_total <- sum(activity, na.rm = TRUE)
        if (daily_total > 0) {
          (activity / daily_total) * 100
        } else {
          rep(0, length(activity))
        }
      }
    }, by = .(id, day)]

    cli::cli_alert_success("Activity normalized with proportional handling for SD period")
  } else {
    # Normal normalization: activity as percentage of total daily activity
    dt[, normact := {
      (activity / sum(activity, na.rm = TRUE)) * 100
    }, by = .(id, day)]

    cli::cli_alert_success("Activity normalized by day")
  }

  # Clean up temporary column if it exists
  if ("time_in_day" %in% names(dt)) {
    dt[, time_in_day := NULL]
  }

  # --- 12. Finalize as `behavr` Object ---
  final_ids <- unique(dt$id)
  metadata_final <- metadata_proc[id %in% final_ids]
  final_behavr_table <- behavr::setbehavr(dt, metadata_final)

  if (!behavr::is.behavr(final_behavr_table)) {
    cli::cli_alert_warning("The final data structure may not strictly conform to all `behavr` expectations.")
  }

  cli::cli_alert_success(
    cli::style_bold(cli::col_green("Data preparation complete. Output is a `behavr` table."))
  )

  # --- Return Result ---
  return(final_behavr_table)
}
