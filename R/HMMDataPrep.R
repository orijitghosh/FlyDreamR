#' Prepare DAM Activity Data for HMM Analysis
#'
#' @description
#' Processes Drosophila Activity Monitor (DAM) data by loading raw monitor files,
#' linking them with metadata, calculating derived features (day, phase, normalized
#' activity), and filtering by date range. The output is a \code{behavr} table
#' ready for Hidden Markov Model analysis.
#'
#' This is typically the first step in the FlyDreamR workflow, converting raw
#' DAM files into a standardized format suitable for \code{\link{HMMbehavr}}.
#'
#' @param metafile_path Character string. Full path to the metadata CSV file
#'   generated by \code{\link{convMasterToMeta}}. This file must contain columns:
#'   \code{file}, \code{start_datetime}, \code{stop_datetime}, \code{region_id},
#'   \code{genotype}, and \code{replicate}.
#' @param result_dir Character string. Directory path containing the raw DAM
#'   monitor files referenced in the metadata. Defaults to current working
#'   directory (\code{getwd()}).
#' @param ldcyc Numeric. Duration of the light phase in hours within a 24-hour
#'   cycle. For example, use 12 for LD 12:12, or 16 for LD 16:8. Default: 12.
#'   Used to assign time points to "Light" or "Dark" phases.
#' @param day_range Numeric vector of length 2. Specifies \code{c(start_day, end_day)}
#'   to retain for analysis (inclusive). Days are numbered starting from 1.
#'   \itemize{
#'     \item Use \code{c(1, 3)} to keep days 1, 2, and 3
#'     \item Use \code{c(2, 2)} to keep only day 2
#'     \item Use \code{c(1, 5)} to keep days 1 through 5
#'   }
#'   Default: \code{c(1, 2)} (first two days).
#' @param ... Additional arguments passed to \code{\link{sleepDAMAnnotation}}.
#'   Most commonly used:
#'   \describe{
#'     \item{\code{min_time_immobile}}{A vector of length 2 specifying the
#'       minimum and maximum duration (in seconds) for an immobility bout to be
#'       considered sleep. Default: \code{c(behavr::mins(5), behavr::mins(1440))}.
#'       For example, use \code{c(behavr::mins(10), behavr::mins(1440))} to
#'       require 10 minutes of immobility.}
#'   }
#'
#' @return A \code{behavr} table (class \code{behavr} and \code{data.table})
#'   containing processed activity data with both original metadata columns and
#'   newly calculated columns:
#'
#'   **Metadata columns** (from input):
#'   \itemize{
#'     \item \code{id}: Unique identifier for each individual
#'     \item \code{genotype}: Genotype/line identifier
#'     \item \code{replicate}: Replicate identifier
#'   }
#'
#'   **Activity columns** (from DAM files):
#'   \itemize{
#'     \item \code{t}: Time in seconds from experiment start
#'     \item \code{activity}: Raw activity count (beam crossings)
#'     \item \code{asleep}: Logical, sleep state annotation
#'   }
#'
#'   **Calculated columns** (added by this function):
#'   \itemize{
#'     \item \code{moving}: Logical, \code{TRUE} if activity > 0
#'     \item \code{day}: Integer day number (1, 2, 3, ...)
#'     \item \code{phase}: Factor with levels "Light" and "Dark"
#'     \item \code{normact}: Normalized activity as percentage of daily total (0-100)
#'   }
#'
#' @details
#' ## Metadata File Format**
#' The \code{metadata_file} must be a CSV with one row per fly (channel) and the following columns:
#' \describe{
#'   \item{\code{file}}{Full filename of the raw monitor file (e.g., "Monitor1.txt").}
#'   \item{\code{start_datetime}}{Experiment start timestamp ("YYYY-MM-DD HH:MM:SS").}
#'   \item{\code{stop_datetime}}{Experiment end timestamp ("YYYY-MM-DD HH:MM:SS").}
#'   \item{\code{region_id}}{Channel number (1-32) on the DAM monitor.}
#'   \item{\code{genotype}}{Experimental genotype identifier.}
#'   \item{\code{replicate}}{Replicate number (integer). Use a random number if not applicable.}
#' }
#'
#' ## Activity Normalization
#' \code{normact} represents activity as a percentage of total daily activity:
#' \code{normact = (activity / sum(daily_activity)) * 100}
#'
#' This normalization accounts for individual differences in baseline activity
#' levels and is used by the HMM fitting process.
#'
#' ## Error Handling
#' The function will stop with an error if:
#' \itemize{
#'   \item Metadata file doesn't exist or can't be read
#'   \item DAM files referenced in metadata are missing
#'   \item No data remains after day filtering
#'   \item Required columns are missing from loaded data
#' }
#'
#' @examples
#' \dontrun{
#' # Basic usage with default parameters
#' processed_data <- HMMDataPrep(
#'   metafile_path = "metadata/Metadata_Monitor1.csv"
#' )
#'
#' # Specify DAM file directory and custom day range
#' processed_data <- HMMDataPrep(
#'   metafile_path = "metadata/experiment1_metadata.csv",
#'   result_dir = "raw_dam_files/",
#'   day_range = c(2, 4)  # Analyze days 2-4 only
#' )
#'
#' # Custom light cycle (LD 16:8) and longer immobility threshold
#' processed_data <- HMMDataPrep(
#'   metafile_path = "metadata/experiment2_metadata.csv",
#'   ldcyc = 16,  # 16 hours of light
#'   min_time_immobile = c(behavr::mins(10), behavr::mins(1440))  # 10 min threshold
#' )
#'
#' # Inspect the output
#' print(head(processed_data))
#' summary(processed_data$normact)
#' table(processed_data$phase, processed_data$day)
#'
#' # Check data coverage
#' unique(processed_data$id)  # List all individuals
#' range(processed_data$day)  # Day range in data
#' }
#'
#' @seealso
#' \code{\link{convMasterToMeta}} for generating metadata files
#' \code{\link{HMMbehavr}} for running HMM analysis on prepared data
#' \code{\link{sleepDAMAnnotation}} for sleep annotation details
#' \code{\link[damr]{load_dam}} for DAM file loading
#'
#' @export
#' @import data.table
#' @importFrom damr link_dam_metadata load_dam
#' @importFrom behavr xmv days hours setbehavr is.behavr
#' @importFrom cli cli_alert_success cli_alert_info cli_alert_warning cli_alert_danger col_yellow col_cyan col_green col_red
#' @importFrom stats quantile na.omit
#' @importFrom utils packageVersion
HMMDataPrep <- function(metafile_path,
                        result_dir = getwd(),
                        ldcyc = 12,
                        day_range = c(1, 2),
                        ...) {
  # --- 1. Input Validation and Setup ---
  # Check required packages silently, stop if missing
  pkgs <- c("data.table", "damr", "behavr", "cli")
  missing_pkgs <- pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
  if (length(missing_pkgs) > 0) {
    stop("Required packages are not installed: ", paste(missing_pkgs, collapse = ", "))
  }

  # Validate inputs
  if (!is.character(metafile_path) || length(metafile_path) != 1 || !file.exists(metafile_path)) {
    stop("`metafile_path` must be a valid path to an existing file.")
  }
  if (!is.character(result_dir) || length(result_dir) != 1) {
    stop("`result_dir` must be a single character string path.")
  }
  # Check if directory exists, warn if not (damr might handle some cases)
  if (!dir.exists(result_dir)) {
    cli::cli_alert_warning("Specified `result_dir` does not exist: {.path {result_dir}}", wrap = TRUE)
  }
  if (!is.numeric(ldcyc) || length(ldcyc) != 1 || !is.finite(ldcyc) || ldcyc <= 0 || ldcyc >= 24) {
    cli::cli_alert_warning("`ldcyc` should be a single positive number < 24. Resetting to default: 12")
    ldcyc <- 12
  }
  if (!is.numeric(day_range) || length(day_range) != 2 || any(!is.finite(day_range)) || day_range[1] < 1 || day_range[2] < day_range[1]) {
    stop("`day_range` must be a numeric vector of length 2 (start_day, end_day), with start_day >= 1 and end_day >= start_day.")
  }
  day_range <- floor(day_range) # Ensure integer days

  cli::cli_alert_info("Starting data preparation...")
  cli::cli_alert_info("Using parameters: light_duration={ldcyc}h, day_range=[{day_range[1]}, {day_range[2]}]")

  # --- 2. Load Metadata ---
  metadata <- tryCatch(
    {
      # Use paste0() defensively in case path needs it, though fread usually handles paths well
      data.table::fread(paste0(metafile_path), na.strings = c("NA", ""))
    },
    error = function(e) {
      stop("Failed to read metadata file: ", metafile_path, "\nError details: ", e$message)
    }
  )
  cli::cli_alert_success("Metadata file read successfully: {.path {metafile_path}}")

  # --- 3. Handle Missing Data in Metadata---
  initial_rows <- nrow(metadata)
  # Consider checking specific essential columns for NA instead of omitting entire row?
  # For now, keep na.omit as it matches the original logic.
  metadata <- stats::na.omit(metadata)
  final_rows <- nrow(metadata)
  if (final_rows < initial_rows) {
    cli::cli_alert_warning("{initial_rows - final_rows} rows removed from metadata due to NA values.")
  }
  if (final_rows == 0) {
    stop("No valid metadata rows remaining after removing NAs. Cannot proceed.")
  }

  # --- 4. Link Metadata to DAM Files ---
  metadata_proc <- tryCatch(
    {
      # link_dam_metadata adds file paths and validates metadata
      damr::link_dam_metadata(metadata, result_dir = result_dir)
    },
    error = function(e) {
      stop("Failed during `damr::link_dam_metadata`. Check metadata content (esp. file references) and `result_dir` path.\nError details: ", e$message)
    }
  )
  cli::cli_alert_success(cli::style_bold(cli::col_yellow("Metadata linked to DAM files.")))

  # --- 5. Load DAM Activity Data ---
  # `load_dam` returns a behavr table (inherits data.table) with time 't'
  dt <- tryCatch(
    {
      damr::load_dam(metadata_proc, FUN = sleepDAMAnnotation, ...)
    },
    error = function(e) {
      stop("Failed during `damr::load_dam`. Check DAM file paths in metadata and file integrity.\nError details: ", e$message)
    }
  )
  cli::cli_alert_success(cli::style_bold(cli::col_cyan("DAM activity data loaded ({nrow(dt)} rows).")))

  # --- 6. Basic Feature: Moving Status ---
  dt[, moving := activity > 0]
  dt[, genotype := behavr::xmv(genotype)]
  dt[, replicate := behavr::xmv(replicate)]

  # --- 7. Calculate Day ---
  # Ensure time column 't' (seconds) exists
  if (!"t" %in% names(dt)) {
    stop("Required column 't' (time in seconds) not found after loading data. Check `damr::load_dam` behavior.")
  }
  dt[, day := floor(t / behavr::days(1)) + 1] # Day 1 starts at t=0 up to t=86399

  # --- 8. Calculate Phase ---
  # Based on time within a 24h cycle vs light duration
  dt[, phase := ifelse(t %% behavr::hours(24) >= behavr::hours(ldcyc), "Dark", "Light")]
  # Ensure consistent factor levels
  dt[, phase := factor(phase, levels = c("Light", "Dark"))]

  # --- 9. Filter by Day Range ---
  initial_rows_filter <- nrow(dt)
  dt <- dt[data.table::between(day, day_range[1], day_range[2], incbounds = TRUE)]
  final_rows_filter <- nrow(dt)
  cli::cli_alert_info("Filtered data by day range [{day_range[1]}, {day_range[2]}]. Kept {final_rows_filter} of {initial_rows_filter} rows.")

  # Check if any data remains after filtering
  if (final_rows_filter == 0) {
    cli::cli_alert_danger(cli::style_bold(cli::col_red(
      "CRITICAL: No data remains after filtering for day range [{day_range[1]}, {day_range[2]}]. Check input data coverage and `day_range` parameter."
    )))
    # Stop execution as subsequent steps will fail
    stop("No data remains after day filtering.")
  }

  # --- 10. Normalize Activity ---
  # Calculate 'normact': activity as a percentage of total daily activity per individual
  # Handle potential division by zero if an animal has zero activity all day
  dt[, normact := {
    (activity / sum(activity, na.rm = TRUE)) * 100
  }, by = .(id, day)] # Group by individual and day

  # --- 11. Finalize as `behavr` Object ---
  # Ensure the output table maintains behavr class and metadata linkage
  # Use the metadata_proc corresponding to the potentially filtered data
  # Filter metadata_proc to only include IDs present in the final 'dt'?
  final_ids <- unique(dt$id)
  metadata_final <- metadata_proc[id %in% final_ids]
  # Re-apply setbehavr to ensure linkage is correct after filtering
  final_behavr_table <- behavr::setbehavr(dt, metadata_final)

  # Optional final check
  if (!behavr::is.behavr(final_behavr_table)) {
    cli::cli_alert_warning("The final data structure may not strictly conform to all `behavr` expectations.")
  }

  cli::cli_alert_success(
    cli::style_bold(cli::col_green("Data preparation complete. Output is a `behavr` table."))
  )

  # --- Return Result ---
  return(final_behavr_table)
}
